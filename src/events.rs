//! Event Sourcing for Trading System State
//!
//! This module provides an append-only event log for perfect deterministic replay
//! and crash recovery. Events are persisted to a JSONL file and can be replayed
//! to reconstruct system state.

use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use std::fs::{File, OpenOptions};
use std::io::{BufRead, BufReader, BufWriter, Write};
use std::path::Path;
use tracing::{info, warn};

/// Default event log file path
pub const DEFAULT_EVENT_LOG_FILE: &str = "trade_journal.jsonl";

/// All system events that modify trading state.
///
/// Events are serialized with a "type" tag for easy parsing and debugging.
/// Each event includes a timestamp for ordering and replay.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type")]
pub enum SystemEvent {
    /// A trading signal was generated by the strategy
    SignalGenerated {
        timestamp_ms: i64,
        symbol: String,
        signal: String, // "Buy", "Sell", "Hold", "Exit"
        z_score: Option<f64>,
    },
    /// An order was placed on the exchange
    OrderPlaced {
        timestamp_ms: i64,
        symbol: String,
        side: String,
        quantity: Decimal,
        order_id: Option<String>,
    },
    /// An order was filled
    FillReceived {
        timestamp_ms: i64,
        symbol: String,
        side: String,
        quantity: Decimal,
        fill_price: Decimal,
        order_id: String,
    },
    /// A position was closed
    PositionClosed {
        timestamp_ms: i64,
        symbol: String,
        entry_price: Decimal,
        exit_price: Decimal,
        quantity: Decimal,
        realized_pnl: Decimal,
    },
}

impl SystemEvent {
    /// Get the timestamp of the event
    pub fn timestamp_ms(&self) -> i64 {
        match self {
            SystemEvent::SignalGenerated { timestamp_ms, .. } => *timestamp_ms,
            SystemEvent::OrderPlaced { timestamp_ms, .. } => *timestamp_ms,
            SystemEvent::FillReceived { timestamp_ms, .. } => *timestamp_ms,
            SystemEvent::PositionClosed { timestamp_ms, .. } => *timestamp_ms,
        }
    }

    /// Get the symbol associated with the event
    pub fn symbol(&self) -> &str {
        match self {
            SystemEvent::SignalGenerated { symbol, .. } => symbol,
            SystemEvent::OrderPlaced { symbol, .. } => symbol,
            SystemEvent::FillReceived { symbol, .. } => symbol,
            SystemEvent::PositionClosed { symbol, .. } => symbol,
        }
    }
}

/// Event log writer for append-only persistence.
///
/// # Performance
/// Uses BufWriter for efficient batch writes. Each event is flushed immediately
/// to ensure durability, but buffering reduces syscall overhead.
pub struct EventLog {
    path: String,
}

impl EventLog {
    /// Create a new event log with the specified path
    pub fn new(path: impl Into<String>) -> Self {
        Self { path: path.into() }
    }

    /// Create an event log with the default path
    pub fn default_path() -> Self {
        Self::new(DEFAULT_EVENT_LOG_FILE)
    }

    /// Append a system event to the log.
    ///
    /// # Performance
    /// - Opens file in append mode (O_APPEND is atomic on POSIX)
    /// - Uses BufWriter for efficiency
    /// - Flushes and syncs after each event for durability
    ///
    /// # Durability
    /// Calls `sync_all()` to ensure data is persisted to disk, not just OS buffer.
    pub fn append(&self, event: &SystemEvent) -> std::io::Result<()> {
        let file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.path)?;
        let mut writer = BufWriter::new(file);
        serde_json::to_writer(&mut writer, event)?;
        writeln!(writer)?;
        writer.flush()?;
        // MC-3 FIX: Ensure data is synced to disk, not just OS buffer
        writer.get_ref().sync_all()
    }

    /// Hydrate state by replaying all events from the log.
    ///
    /// # Safety
    /// Handles corrupted tail records (e.g., partial writes from power failure)
    /// by discarding the incomplete line and logging a warning.
    ///
    /// # Returns
    /// A vector of all successfully parsed events in chronological order.
    pub fn replay(&self) -> Vec<SystemEvent> {
        let path = Path::new(&self.path);
        if !path.exists() {
            info!("No event log found at '{}', starting fresh", self.path);
            return Vec::new();
        }

        let file = match File::open(path) {
            Ok(f) => f,
            Err(e) => {
                warn!("Failed to open event log '{}': {}", self.path, e);
                return Vec::new();
            }
        };

        let reader = BufReader::new(file);
        let mut events = Vec::new();
        let mut line_num = 0;
        let mut corrupted_count = 0;

        for line in reader.lines() {
            line_num += 1;

            let line = match line {
                Ok(l) if !l.trim().is_empty() => l,
                Ok(_) => continue, // Skip empty lines
                Err(e) => {
                    warn!(
                        "I/O error reading event log at line {}: {} (possible truncation)",
                        line_num, e
                    );
                    corrupted_count += 1;
                    continue;
                }
            };

            match serde_json::from_str::<SystemEvent>(&line) {
                Ok(event) => events.push(event),
                Err(e) => {
                    // Handle corrupted tail records (partial writes during crash)
                    warn!(
                        "Skipping malformed event at line {}: {} (content: '{}')",
                        line_num,
                        e,
                        if line.len() > 50 {
                            format!("{}...", &line[..50])
                        } else {
                            line
                        }
                    );
                    corrupted_count += 1;
                }
            }
        }

        if corrupted_count > 0 {
            warn!(
                "Event log replay completed with {} corrupted/skipped lines",
                corrupted_count
            );
        }

        info!(
            "Hydrated {} events from '{}' ({} lines processed)",
            events.len(),
            self.path,
            line_num
        );

        events
    }

    /// Get the path to the event log
    pub fn path(&self) -> &str {
        &self.path
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rust_decimal_macros::dec;
    use std::io::Write;
    use tempfile::tempdir;

    #[test]
    fn test_append_and_replay_events() {
        let dir = tempdir().unwrap();
        let log_path = dir.path().join("test_journal.jsonl");
        let log = EventLog::new(log_path.to_str().unwrap());

        // Append some events
        let event1 = SystemEvent::SignalGenerated {
            timestamp_ms: 1000,
            symbol: "BTC-USD".into(),
            signal: "Buy".into(),
            z_score: Some(-2.5),
        };
        let event2 = SystemEvent::FillReceived {
            timestamp_ms: 1001,
            symbol: "BTC-USD".into(),
            side: "buy".into(),
            quantity: dec!(0.1),
            fill_price: dec!(50000.0),
            order_id: "order-123".into(),
        };

        log.append(&event1).unwrap();
        log.append(&event2).unwrap();

        // Replay and verify
        let events = log.replay();
        assert_eq!(events.len(), 2);
        assert_eq!(events[0], event1);
        assert_eq!(events[1], event2);
    }

    #[test]
    fn test_corrupted_tail_recovery() {
        let dir = tempdir().unwrap();
        let log_path = dir.path().join("corrupted_journal.jsonl");

        // Write valid event + corrupted partial line
        {
            let mut file = File::create(&log_path).unwrap();
            writeln!(
                file,
                r#"{{"type":"SignalGenerated","timestamp_ms":1,"symbol":"X","signal":"Buy","z_score":null}}"#
            )
            .unwrap();
            // Simulated power failure - incomplete JSON
            write!(file, r#"{{"type":"FillReceived","timestamp_ms":2"#).unwrap();
        }

        let log = EventLog::new(log_path.to_str().unwrap());
        let events = log.replay();

        // Should recover 1 event, skip the corrupted line
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].symbol(), "X");
    }

    #[test]
    fn test_empty_log_returns_empty_vec() {
        let dir = tempdir().unwrap();
        let log_path = dir.path().join("nonexistent.jsonl");
        let log = EventLog::new(log_path.to_str().unwrap());

        let events = log.replay();
        assert!(events.is_empty());
    }

    #[test]
    fn test_event_timestamp_accessor() {
        let event = SystemEvent::OrderPlaced {
            timestamp_ms: 12345,
            symbol: "ETH-USD".into(),
            side: "sell".into(),
            quantity: dec!(1.0),
            order_id: Some("abc".into()),
        };
        assert_eq!(event.timestamp_ms(), 12345);
        assert_eq!(event.symbol(), "ETH-USD");
    }
}
